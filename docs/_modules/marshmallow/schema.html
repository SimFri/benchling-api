<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>marshmallow.schema &#8212; benchlingapi 2.0.2a documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/style.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          BenchlingAPI</a>
        <span class="navbar-text navbar-version pull-left"><b>2.0.2a</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">BenchlingAPI <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../session.html">Session (<code class="xref py py-mod docutils literal notranslate"><span class="pre">benchlingapi.session</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../models.html">Models (<code class="xref py py-mod docutils literal notranslate"><span class="pre">benchlingapi.models.models</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../models.html#models">Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.models.DNASequence.html">benchlingapi.models.models.DNASequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.models.AASequence.html">benchlingapi.models.models.AASequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.models.Oligo.html">benchlingapi.models.models.Oligo</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.models.Annotation.html">benchlingapi.models.models.Annotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.models.Translation.html">benchlingapi.models.models.Translation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.models.CustomEntity.html">benchlingapi.models.models.CustomEntity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.models.EntitySchema.html">benchlingapi.models.models.EntitySchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.models.Project.html">benchlingapi.models.models.Project</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.models.Registry.html">benchlingapi.models.models.Registry</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.models.Translation.html">benchlingapi.models.models.Translation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../models.html#schemas">Schemas</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.DNASequenceSchema.html">benchlingapi.models.schema.DNASequenceSchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.AASequenceSchema.html">benchlingapi.models.schema.AASequenceSchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.BatchSchema.html">benchlingapi.models.schema.BatchSchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.CustomEntitySchema.html">benchlingapi.models.schema.CustomEntitySchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.DNASequenceSchema.html">benchlingapi.models.schema.DNASequenceSchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.EntitySchema.html">benchlingapi.models.schema.EntitySchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.EntitySchemaSchema.html">benchlingapi.models.schema.EntitySchemaSchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.FieldSchema.html">benchlingapi.models.schema.FieldSchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.FolderSchema.html">benchlingapi.models.schema.FolderSchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.OligoSchema.html">benchlingapi.models.schema.OligoSchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.ProjectSchema.html">benchlingapi.models.schema.ProjectSchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.RegistrySchema.html">benchlingapi.models.schema.RegistrySchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.TranslationSchema.html">benchlingapi.models.schema.TranslationSchema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/benchlingapi.models.schema.UserSummarySchema.html">benchlingapi.models.schema.UserSummarySchema</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../exceptions.html">Exceptions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">benchlingapi.exceptions</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">Utilities (<code class="xref py py-mod docutils literal notranslate"><span class="pre">benchlingapi.utils</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../usage.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usage.html#session">Session</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../guidelines.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../guidelines.html#adding-a-new-model">Adding a new model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guidelines.html#running-tests">Running tests</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for marshmallow.schema</h1><div class="highlight"><pre>
<span></span># -*- coding: utf-8 -*-
&quot;&quot;&quot;The :class:`Schema` class, including its metaclass and options (class Meta).&quot;&quot;&quot;
from __future__ import absolute_import, unicode_literals

from collections import defaultdict, OrderedDict
import datetime as dt
import uuid
import decimal
import functools
import copy
import inspect
import json
import warnings

from marshmallow import base, fields, utils, class_registry, marshalling
from marshmallow.compat import iteritems, iterkeys, with_metaclass, text_type, binary_type
from marshmallow.exceptions import ValidationError, StringNotCollectionError
from marshmallow.orderedset import OrderedSet
from marshmallow.decorators import (
    POST_DUMP,
    POST_LOAD,
    PRE_DUMP,
    PRE_LOAD,
    VALIDATES,
    VALIDATES_SCHEMA,
)
from marshmallow.utils import RAISE, missing, is_collection


def _get_fields(attrs, field_class, pop=False, ordered=False):
    &quot;&quot;&quot;Get fields from a class. If ordered=True, fields will sorted by creation index.

    :param attrs: Mapping of class attributes
    :param type field_class: Base field class
    :param bool pop: Remove matching fields
    &quot;&quot;&quot;
    fields = [
        (field_name, field_value)
        for field_name, field_value in iteritems(attrs)
        if utils.is_instance_or_subclass(field_value, field_class)
    ]
    if pop:
        for field_name, _ in fields:
            del attrs[field_name]
    if ordered:
        fields.sort(key=lambda pair: pair[1]._creation_index)
    return fields

# This function allows Schemas to inherit from non-Schema classes and ensures
#   inheritance according to the MRO
def _get_fields_by_mro(klass, field_class, ordered=False):
    &quot;&quot;&quot;Collect fields from a class, following its method resolution order. The
    class itself is excluded from the search; only its parents are checked. Get
    fields from ``_declared_fields`` if available, else use ``__dict__``.

    :param type klass: Class whose fields to retrieve
    :param type field_class: Base field class
    &quot;&quot;&quot;
    mro = inspect.getmro(klass)
    # Loop over mro in reverse to maintain correct order of fields
    return sum(
        (
            _get_fields(
                getattr(base, &#39;_declared_fields&#39;, base.__dict__),
                field_class,
                ordered=ordered,
            )
            for base in mro[:0:-1]
        ),
        [],
    )


class SchemaMeta(type):
    &quot;&quot;&quot;Metaclass for the Schema class. Binds the declared fields to
    a ``_declared_fields`` attribute, which is a dictionary mapping attribute
    names to field objects. Also sets the ``opts`` class attribute, which is
    the Schema class&#39;s ``class Meta`` options.
    &quot;&quot;&quot;

    def __new__(mcs, name, bases, attrs):
        meta = attrs.get(&#39;Meta&#39;)
        ordered = getattr(meta, &#39;ordered&#39;, False)
        if not ordered:
            # Inherit &#39;ordered&#39; option
            # Warning: We loop through bases instead of MRO because we don&#39;t
            # yet have access to the class object
            # (i.e. can&#39;t call super before we have fields)
            for base_ in bases:
                if hasattr(base_, &#39;Meta&#39;) and hasattr(base_.Meta, &#39;ordered&#39;):
                    ordered = base_.Meta.ordered
                    break
            else:
                ordered = False
        cls_fields = _get_fields(attrs, base.FieldABC, pop=True, ordered=ordered)
        klass = super(SchemaMeta, mcs).__new__(mcs, name, bases, attrs)
        inherited_fields = _get_fields_by_mro(klass, base.FieldABC, ordered=ordered)

        # Use getattr rather than attrs[&#39;Meta&#39;] so that we get inheritance for free
        meta = getattr(klass, &#39;Meta&#39;)
        # Set klass.opts in __new__ rather than __init__ so that it is accessible in
        # get_declared_fields
        klass.opts = klass.OPTIONS_CLASS(meta, ordered=ordered)
        # Add fields specifid in the `include` class Meta option
        cls_fields += list(klass.opts.include.items())

        dict_cls = OrderedDict if ordered else dict
        # Assign _declared_fields on class
        klass._declared_fields = mcs.get_declared_fields(
            klass=klass,
            cls_fields=cls_fields,
            inherited_fields=inherited_fields,
            dict_cls=dict_cls,
        )
        return klass

    @classmethod
    def get_declared_fields(mcs, klass, cls_fields, inherited_fields, dict_cls):
        &quot;&quot;&quot;Returns a dictionary of field_name =&gt; `Field` pairs declard on the class.
        This is exposed mainly so that plugins can add additional fields, e.g. fields
        computed from class Meta options.

        :param type klass: The class object.
        :param dict cls_fields: The fields declared on the class, including those added
            by the ``include`` class Meta option.
        :param dict inherited_fileds: Inherited fields.
        :param type dict_class: Either `dict` or `OrderedDict`, depending on the whether
            the user specified `ordered=True`.
        &quot;&quot;&quot;
        return dict_cls(inherited_fields + cls_fields)

    # NOTE: self is the class object
    def __init__(self, name, bases, attrs):
        super(SchemaMeta, self).__init__(name, bases, attrs)
        if name:
            class_registry.register(name, self)
        self._hooks = self.resolve_hooks()

    def resolve_hooks(self):
        &quot;&quot;&quot;Add in the decorated processors

        By doing this after constructing the class, we let standard inheritance
        do all the hard work.
        &quot;&quot;&quot;
        mro = inspect.getmro(self)

        hooks = defaultdict(list)

        for attr_name in dir(self):
            # Need to look up the actual descriptor, not whatever might be
            # bound to the class. This needs to come from the __dict__ of the
            # declaring class.
            for parent in mro:
                try:
                    attr = parent.__dict__[attr_name]
                except KeyError:
                    continue
                else:
                    break
            else:
                # In case we didn&#39;t find the attribute and didn&#39;t break above.
                # We should never hit this - it&#39;s just here for completeness
                # to exclude the possibility of attr being undefined.
                continue

            try:
                hook_config = attr.__marshmallow_hook__
            except AttributeError:
                pass
            else:
                for key in iterkeys(hook_config):
                    # Use name here so we can get the bound method later, in
                    # case the processor was a descriptor or something.
                    hooks[key].append(attr_name)

        return hooks


class SchemaOpts(object):
    &quot;&quot;&quot;class Meta options for the :class:`Schema`. Defines defaults.&quot;&quot;&quot;

    def __init__(self, meta, ordered=False):
        self.fields = getattr(meta, &#39;fields&#39;, ())
        if not isinstance(self.fields, (list, tuple)):
            raise ValueError(&#39;`fields` option must be a list or tuple.&#39;)
        self.additional = getattr(meta, &#39;additional&#39;, ())
        if not isinstance(self.additional, (list, tuple)):
            raise ValueError(&#39;`additional` option must be a list or tuple.&#39;)
        if self.fields and self.additional:
            raise ValueError(
                &#39;Cannot set both `fields` and `additional` options&#39;
                &#39; for the same Schema.&#39;,
            )
        self.exclude = getattr(meta, &#39;exclude&#39;, ())
        if not isinstance(self.exclude, (list, tuple)):
            raise ValueError(&#39;`exclude` must be a list or tuple.&#39;)
        self.dateformat = getattr(meta, &#39;dateformat&#39;, None)
        self.datetimeformat = getattr(meta, &#39;datetimeformat&#39;, None)
        if hasattr(meta, &#39;json_module&#39;):
            warnings.warn(
                &#39;The json_module class Meta option is deprecated. Use render_module instead.&#39;,
                DeprecationWarning,
            )
            render_module = getattr(meta, &#39;json_module&#39;, json)
        else:
            render_module = json
        self.render_module = getattr(meta, &#39;render_module&#39;, render_module)
        self.ordered = getattr(meta, &#39;ordered&#39;, ordered)
        self.index_errors = getattr(meta, &#39;index_errors&#39;, True)
        self.include = getattr(meta, &#39;include&#39;, {})
        self.load_only = getattr(meta, &#39;load_only&#39;, ())
        self.dump_only = getattr(meta, &#39;dump_only&#39;, ())
        self.unknown = getattr(meta, &#39;unknown&#39;, RAISE)


class BaseSchema(base.SchemaABC):
    &quot;&quot;&quot;Base schema class with which to define custom schemas.

    Example usage:

    .. code-block:: python

        import datetime as dt
        from marshmallow import Schema, fields

        class Album(object):
            def __init__(self, title, release_date):
                self.title = title
                self.release_date = release_date

        class AlbumSchema(Schema):
            title = fields.Str()
            release_date = fields.Date()

        # Or, equivalently
        class AlbumSchema2(Schema):
            class Meta:
                fields = (&quot;title&quot;, &quot;release_date&quot;)

        album = Album(&quot;Beggars Banquet&quot;, dt.date(1968, 12, 6))
        schema = AlbumSchema()
        data, errors = schema.dump(album)
        data  # {&#39;release_date&#39;: &#39;1968-12-06&#39;, &#39;title&#39;: &#39;Beggars Banquet&#39;}

    :param tuple|list only: Whitelist of the declared fields to select when
        instantiating the Schema. If None, all fields are used. Nested fields
        can be represented with dot delimiters.
    :param tuple|list exclude: Blacklist of the declared fields to exclude
        when instantiating the Schema. If a field appears in both `only` and
        `exclude`, it is not used. Nested fields can be represented with dot
        delimiters.
    :param bool many: Should be set to `True` if ``obj`` is a collection
        so that the object will be serialized to a list.
    :param dict context: Optional context passed to :class:`fields.Method` and
        :class:`fields.Function` fields.
    :param tuple|list load_only: Fields to skip during serialization (write-only fields)
    :param tuple|list dump_only: Fields to skip during deserialization (read-only fields)
    :param bool|tuple partial: Whether to ignore missing fields. If its value
        is an iterable, only missing fields listed in that iterable will be
        ignored.
    :param unknown: Whether to exclude, include, or raise an error for unknown
        fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.

    .. versionchanged:: 3.0.0
        `prefix` parameter removed.

    .. versionchanged:: 2.0.0
        `__validators__`, `__preprocessors__`, and `__data_handlers__` are removed in favor of
        `marshmallow.decorators.validates_schema`,
        `marshmallow.decorators.pre_load` and `marshmallow.decorators.post_dump`.
        `__accessor__` and `__error_handler__` are deprecated. Implement the
        `handle_error` and `get_attribute` methods instead.
    &quot;&quot;&quot;
    TYPE_MAPPING = {
        text_type: fields.String,
        binary_type: fields.String,
        dt.datetime: fields.DateTime,
        float: fields.Float,
        bool: fields.Boolean,
        tuple: fields.Raw,
        list: fields.Raw,
        set: fields.Raw,
        int: fields.Integer,
        uuid.UUID: fields.UUID,
        dt.time: fields.Time,
        dt.date: fields.Date,
        dt.timedelta: fields.TimeDelta,
        decimal.Decimal: fields.Decimal,
    }

    OPTIONS_CLASS = SchemaOpts

    class Meta(object):
        &quot;&quot;&quot;Options object for a Schema.

        Example usage: ::

            class Meta:
                fields = (&quot;id&quot;, &quot;email&quot;, &quot;date_created&quot;)
                exclude = (&quot;password&quot;, &quot;secret_attribute&quot;)

        Available options:

        - ``fields``: Tuple or list of fields to include in the serialized result.
        - ``additional``: Tuple or list of fields to include *in addition* to the
            explicitly declared fields. ``additional`` and ``fields`` are
            mutually-exclusive options.
        - ``include``: Dictionary of additional fields to include in the schema. It is
            usually better to define fields as class variables, but you may need to
            use this option, e.g., if your fields are Python keywords. May be an
            `OrderedDict`.
        - ``exclude``: Tuple or list of fields to exclude in the serialized result.
            Nested fields can be represented with dot delimiters.
        - ``dateformat``: Date format for all DateTime fields that do not have their
            date format explicitly specified.
        - ``render_module``: Module to use for `loads` and `dumps`. Defaults to
            `json` from the standard library.
        - ``ordered``: If `True`, order serialization output according to the
            order in which fields were declared. Output of `Schema.dump` will be a
            `collections.OrderedDict`.
        - ``index_errors``: If `True`, errors dictionaries will include the index
            of invalid items in a collection.
        - ``load_only``: Tuple or list of fields to exclude from serialized results.
        - ``dump_only``: Tuple or list of fields to exclude from deserialization
        - ``unknown``: Whether to exclude, include, or raise an error for unknown
            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.
        &quot;&quot;&quot;
        pass

    def __init__(
        self, only=None, exclude=(), many=False, context=None,
        load_only=(), dump_only=(), partial=False, unknown=None,
    ):
        # Raise error if only or exclude is passed as string, not list of strings
        if only is not None and not is_collection(only):
            raise StringNotCollectionError(&#39;&quot;only&quot; should be a list of strings&#39;)
        if exclude is not None and not is_collection(exclude):
            raise StringNotCollectionError(&#39;&quot;exclude&quot; should be a list of strings&#39;)
        # copy declared fields from metaclass
        self.declared_fields = copy.deepcopy(self._declared_fields)
        self.many = many
        self.only = only
        self.exclude = exclude
        self.ordered = self.opts.ordered
        self.load_only = set(load_only) or set(self.opts.load_only)
        self.dump_only = set(dump_only) or set(self.opts.dump_only)
        self.partial = partial
        self.unknown = unknown or self.opts.unknown
        self.context = context or {}
        self._normalize_nested_options()
        #: Dictionary mapping field_names -&gt; :class:`Field` objects
        self.fields = self._init_fields()

    def __repr__(self):
        return &#39;&lt;{ClassName}(many={self.many})&gt;&#39;.format(
            ClassName=self.__class__.__name__, self=self,
        )

    @property
    def dict_class(self):
        return OrderedDict if self.ordered else dict

    @property
    def set_class(self):
        return OrderedSet if self.ordered else set

    ##### Override-able methods #####

    def handle_error(self, error, data):
        &quot;&quot;&quot;Custom error handler function for the schema.

        :param ValidationError error: The `ValidationError` raised during (de)serialization.
        :param data: The original input data.

        .. versionadded:: 2.0.0
        &quot;&quot;&quot;
        pass

    def get_attribute(self, obj, attr, default):
        &quot;&quot;&quot;Defines how to pull values from an object to serialize.

        .. versionadded:: 2.0.0

        .. versionchanged:: 3.0.0a1
            Changed position of ``obj`` and ``attr``.
        &quot;&quot;&quot;
        return utils.get_value(obj, attr, default)

    ##### Serialization/Deserialization API #####

    def dump(self, obj, many=None):
        &quot;&quot;&quot;Serialize an object to native Python data types according to this
        Schema&#39;s fields.

        :param obj: The object to serialize.
        :param bool many: Whether to serialize `obj` as a collection. If `None`, the value
            for `self.many` is used.
        :return: A dict of serialized data
        :rtype: dict

        .. versionadded:: 1.0.0
        .. versionchanged:: 3.0.0b7
            This method returns the serialized data rather than a ``(data, errors)`` duple.
            A :exc:`ValidationError &lt;marshmallow.exceptions.ValidationError&gt;` is raised
            if ``obj`` is invalid.
        &quot;&quot;&quot;
        # Callable marshalling object
        marshal = marshalling.Marshaller()
        errors = {}
        many = self.many if many is None else bool(many)
        if many and utils.is_iterable_but_not_string(obj):
            obj = list(obj)

        if self._has_processors(PRE_DUMP):
            try:
                processed_obj = self._invoke_dump_processors(
                    PRE_DUMP,
                    obj,
                    many,
                    original_data=obj,
                )
            except ValidationError as error:
                errors = error.normalized_messages()
                result = None
        else:
            processed_obj = obj

        if not errors:
            result = marshal(
                processed_obj,
                self.fields,
                many=many,
                accessor=self.get_attribute,
                dict_class=self.dict_class,
                index_errors=self.opts.index_errors,
            )
            errors = marshal.errors

        if not errors and self._has_processors(POST_DUMP):
            try:
                result = self._invoke_dump_processors(
                    POST_DUMP,
                    result,
                    many,
                    original_data=obj,
                )
            except ValidationError as error:
                errors = error.normalized_messages()
        if errors:
            exc = ValidationError(
                errors,
                data=obj,
                valid_data=result,
                **marshal.error_kwargs
            )
            # User-defined error handler
            self.handle_error(exc, obj)
            raise exc

        return result

    def dumps(self, obj, many=None, *args, **kwargs):
        &quot;&quot;&quot;Same as :meth:`dump`, except return a JSON-encoded string.

        :param obj: The object to serialize.
        :param bool many: Whether to serialize `obj` as a collection. If `None`, the value
            for `self.many` is used.
        :return: A ``json`` string
        :rtype: str

        .. versionadded:: 1.0.0
        .. versionchanged:: 3.0.0b7
            This method returns the serialized data rather than a ``(data, errors)`` duple.
            A :exc:`ValidationError &lt;marshmallow.exceptions.ValidationError&gt;` is raised
            if ``obj`` is invalid.
        &quot;&quot;&quot;
        serialized = self.dump(obj, many=many)
        return self.opts.render_module.dumps(serialized, *args, **kwargs)

    def load(self, data, many=None, partial=None, unknown=None):
        &quot;&quot;&quot;Deserialize a data structure to an object defined by this Schema&#39;s fields.

        :param dict data: The data to deserialize.
        :param bool many: Whether to deserialize `data` as a collection. If `None`, the
            value for `self.many` is used.
        :param bool|tuple partial: Whether to ignore missing fields. If `None`,
            the value for `self.partial` is used. If its value is an iterable,
            only missing fields listed in that iterable will be ignored.
            Use dot delimiters to specify nested fields.
        :param unknown: Whether to exclude, include, or raise an error for unknown
            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.
            If `None`, the value for `self.unknown` is used.
        :return: A dict of deserialized data
        :rtype: dict

        .. versionadded:: 1.0.0
        .. versionchanged:: 3.0.0b7
            This method returns the deserialized data rather than a ``(data, errors)`` duple.
            A :exc:`ValidationError &lt;marshmallow.exceptions.ValidationError&gt;` is raised
            if invalid data are passed.
        &quot;&quot;&quot;
        return self._do_load(
            data, many, partial=partial, unknown=unknown,
            postprocess=True,
        )

    def loads(
        self, json_data, many=None, partial=None, unknown=None,
        **kwargs
    ):
        &quot;&quot;&quot;Same as :meth:`load`, except it takes a JSON string as input.

        :param str json_data: A JSON string of the data to deserialize.
        :param bool many: Whether to deserialize `obj` as a collection. If `None`, the
            value for `self.many` is used.
        :param bool|tuple partial: Whether to ignore missing fields. If `None`,
            the value for `self.partial` is used. If its value is an iterable,
            only missing fields listed in that iterable will be ignored.
            Use dot delimiters to specify nested fields.
        :param unknown: Whether to exclude, include, or raise an error for unknown
            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.
            If `None`, the value for `self.unknown` is used.
        :return: A dict of deserialized data
        :rtype: dict

        .. versionadded:: 1.0.0
        .. versionchanged:: 3.0.0b7
            This method returns the deserialized data rather than a ``(data, errors)`` duple.
            A :exc:`ValidationError &lt;marshmallow.exceptions.ValidationError&gt;` is raised
            if invalid data are passed.
        &quot;&quot;&quot;
        data = self.opts.render_module.loads(json_data, **kwargs)
        return self.load(data, many=many, partial=partial, unknown=unknown)

    def validate(self, data, many=None, partial=None):
        &quot;&quot;&quot;Validate `data` against the schema, returning a dictionary of
        validation errors.

        :param dict data: The data to validate.
        :param bool many: Whether to validate `data` as a collection. If `None`, the
            value for `self.many` is used.
        :param bool|tuple partial: Whether to ignore missing fields. If `None`,
            the value for `self.partial` is used. If its value is an iterable,
            only missing fields listed in that iterable will be ignored.
            Use dot delimiters to specify nested fields.
        :return: A dictionary of validation errors.
        :rtype: dict

        .. versionadded:: 1.1.0
        &quot;&quot;&quot;
        try:
            self._do_load(data, many, partial=partial, postprocess=False)
        except ValidationError as exc:
            return exc.messages
        return {}

    ##### Private Helpers #####

    def _do_load(
        self, data, many=None, partial=None, unknown=None,
        postprocess=True,
    ):
        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.

        :param data: The data to deserialize.
        :param bool many: Whether to deserialize `data` as a collection. If `None`, the
            value for `self.many` is used.
        :param bool|tuple partial: Whether to validate required fields. If its value is an iterable,
            only fields listed in that iterable will be ignored will be allowed missing.
            If `True`, all fields will be allowed missing.
            If `None`, the value for `self.partial` is used.
        :param unknown: Whether to exclude, include, or raise an error for unknown
            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.
            If `None`, the value for `self.unknown` is used.
        :param bool postprocess: Whether to run post_load methods..
        :return: A dict of deserialized data
        :rtype: dict
        &quot;&quot;&quot;
        # Callable unmarshalling object
        unmarshal = marshalling.Unmarshaller()
        errors = {}
        many = self.many if many is None else bool(many)
        unknown = unknown or self.unknown
        if partial is None:
            partial = self.partial
        # Run preprocessors
        if self._has_processors(PRE_LOAD):
            try:
                processed_data = self._invoke_load_processors(
                    PRE_LOAD,
                    data,
                    many,
                    original_data=data,
                )
            except ValidationError as err:
                errors = err.normalized_messages()
                result = None
        else:
            processed_data = data
        if not errors:
            # Deserialize data
            result = unmarshal(
                processed_data,
                self.fields,
                many=many,
                partial=partial,
                unknown=unknown,
                dict_class=self.dict_class,
                index_errors=self.opts.index_errors,
            )
            # Run field-level validation
            self._invoke_field_validators(unmarshal, data=result, many=many)
            # Run schema-level validation
            if self._has_processors(VALIDATES_SCHEMA):
                field_errors = bool(unmarshal.errors)
                self._invoke_schema_validators(
                    unmarshal,
                    pass_many=True,
                    data=result,
                    original_data=data,
                    many=many,
                    field_errors=field_errors,
                )
                self._invoke_schema_validators(
                    unmarshal,
                    pass_many=False,
                    data=result,
                    original_data=data,
                    many=many,
                    field_errors=field_errors,
                )
            errors = unmarshal.errors
            # Run post processors
            if not errors and postprocess and self._has_processors(POST_LOAD):
                try:
                    result = self._invoke_load_processors(
                        POST_LOAD,
                        result,
                        many,
                        original_data=data,
                    )
                except ValidationError as err:
                    errors = err.normalized_messages()
        if errors:
            exc = ValidationError(
                errors,
                data=data,
                valid_data=result,
                **unmarshal.error_kwargs
            )
            self.handle_error(exc, data)
            raise exc

        return result

    def _normalize_nested_options(self):
        &quot;&quot;&quot;Apply then flatten nested schema options&quot;&quot;&quot;
        if self.only is not None:
            # Apply the only option to nested fields.
            self.__apply_nested_option(&#39;only&#39;, self.only, &#39;intersection&#39;)
            # Remove the child field names from the only option.
            self.only = self.set_class(
                [field.split(&#39;.&#39;, 1)[0] for field in self.only],
            )
        excludes = set(self.opts.exclude) | set(self.exclude)
        if excludes:
            # Apply the exclude option to nested fields.
            self.__apply_nested_option(&#39;exclude&#39;, excludes, &#39;union&#39;)
        if self.exclude:
            # Remove the parent field names from the exclude option.
            self.exclude = self.set_class(
                [field for field in self.exclude if &#39;.&#39; not in field],
            )
        if self.opts.exclude:
            # Remove the parent field names from the meta exclude option.
            self.opts.exclude = self.set_class(
                [field for field in self.opts.exclude if &#39;.&#39; not in field],
            )

    def __apply_nested_option(self, option_name, field_names, set_operation):
        &quot;&quot;&quot;Apply nested options to nested fields&quot;&quot;&quot;
        # Split nested field names on the first dot.
        nested_fields = [name.split(&#39;.&#39;, 1) for name in field_names if &#39;.&#39; in name]
        # Partition the nested field names by parent field.
        nested_options = defaultdict(list)
        for parent, nested_names in nested_fields:
            nested_options[parent].append(nested_names)
        # Apply the nested field options.
        for key, options in iter(nested_options.items()):
            new_options = self.set_class(options)
            original_options = getattr(self.declared_fields[key], option_name, ())
            if original_options:
                if set_operation == &#39;union&#39;:
                    new_options |= self.set_class(original_options)
                if set_operation == &#39;intersection&#39;:
                        new_options &amp;= self.set_class(original_options)
            setattr(self.declared_fields[key], option_name, new_options)

    def _init_fields(self):
        &quot;&quot;&quot;Update fields based on schema options.&quot;&quot;&quot;
        if self.opts.fields:
            available_field_names = self.set_class(self.opts.fields)
        else:
            available_field_names = self.set_class(self.declared_fields.keys())
            if self.opts.additional:
                available_field_names |= self.set_class(self.opts.additional)

        invalid_fields = self.set_class()

        if self.only is not None:
            # Return only fields specified in only option
            field_names = self.set_class(self.only)

            invalid_fields |= field_names - available_field_names
        else:
            field_names = available_field_names

        # If &quot;exclude&quot; option or param is specified, remove those fields.
        exclude_field_names = set(self.opts.exclude) | set(self.exclude)
        if exclude_field_names:
            # Note that this isn&#39;t available_field_names, since we want to
            # apply &quot;only&quot; for the actual calculation.
            field_names = field_names - exclude_field_names

            invalid_fields |= exclude_field_names - available_field_names

        if invalid_fields:
            message = &#39;Invalid fields for {0}: {1}.&#39;.format(self, invalid_fields)
            raise ValueError(message)

        fields_dict = self.dict_class()
        for field_name in field_names:
            field_obj = self.declared_fields.get(field_name, fields.Inferred())
            self._bind_field(field_name, field_obj)
            fields_dict[field_name] = field_obj

        dump_data_keys = [
            obj.data_key or name for name, obj in iteritems(fields_dict) if not obj.load_only
        ]
        if len(dump_data_keys) != len(set(dump_data_keys)):
            data_keys_duplicates = {x for x in dump_data_keys if dump_data_keys.count(x) &gt; 1}
            raise ValueError(
                &#39;The data_key argument for one or more fields collides &#39;
                &quot;with another field&#39;s name or data_key argument. &quot;
                &#39;Check the following field names and &#39;
                &#39;data_key arguments: {}&#39;.format(list(data_keys_duplicates)),
            )

        load_attributes = [
            obj.attribute or name for name, obj in iteritems(fields_dict) if not obj.dump_only
        ]
        if len(load_attributes) != len(set(load_attributes)):
            attributes_duplicates = {x for x in load_attributes if load_attributes.count(x) &gt; 1}
            raise ValueError(
                &#39;The attribute argument for one or more fields collides &#39;
                &quot;with another field&#39;s name or attribute argument. &quot;
                &#39;Check the following field names and &#39;
                &#39;attribute arguments: {}&#39;.format(list(attributes_duplicates)),
            )

        return fields_dict

    def on_bind_field(self, field_name, field_obj):
        &quot;&quot;&quot;Hook to modify a field when it is bound to the `Schema`.

        No-op by default.
        &quot;&quot;&quot;
        return None

    def _bind_field(self, field_name, field_obj):
        &quot;&quot;&quot;Bind field to the schema, setting any necessary attributes on the
        field (e.g. parent and name).

        Also set field load_only and dump_only values if field_name was
        specified in ``class Meta``.
        &quot;&quot;&quot;
        try:
            if field_name in self.load_only:
                field_obj.load_only = True
            if field_name in self.dump_only:
                field_obj.dump_only = True
            field_obj._bind_to_schema(field_name, self)
            self.on_bind_field(field_name, field_obj)
        except TypeError:
            # field declared as a class, not an instance
            if (isinstance(field_obj, type) and
                    issubclass(field_obj, base.FieldABC)):
                msg = (&#39;Field for &quot;{0}&quot; must be declared as a &#39;
                       &#39;Field instance, not a class. &#39;
                       &#39;Did you mean &quot;fields.{1}()&quot;?&#39;
                       .format(field_name, field_obj.__name__))
                raise TypeError(msg)

    def _has_processors(self, tag):
        return self._hooks[(tag, True)] or self._hooks[(tag, False)]

    def _invoke_dump_processors(self, tag, data, many, original_data=None):
        # The pass_many post-dump processors may do things like add an envelope, so
        # invoke those after invoking the non-pass_many processors which will expect
        # to get a list of items.
        data = self._invoke_processors(
            tag, pass_many=False,
            data=data, many=many, original_data=original_data,
        )
        data = self._invoke_processors(
            tag, pass_many=True,
            data=data, many=many, original_data=original_data,
        )
        return data

    def _invoke_load_processors(self, tag, data, many, original_data=None):
        # This has to invert the order of the dump processors, so run the pass_many
        # processors first.
        data = self._invoke_processors(
            tag, pass_many=True,
            data=data, many=many, original_data=original_data,
        )
        data = self._invoke_processors(
            tag, pass_many=False,
            data=data, many=many, original_data=original_data,
        )
        return data

    def _invoke_field_validators(self, unmarshal, data, many):
        for attr_name in self._hooks[VALIDATES]:
            validator = getattr(self, attr_name)
            validator_kwargs = validator.__marshmallow_hook__[VALIDATES]
            field_name = validator_kwargs[&#39;field_name&#39;]

            try:
                field_obj = self.fields[field_name]
            except KeyError:
                if field_name in self.declared_fields:
                    continue
                raise ValueError(&#39;&quot;{0}&quot; field does not exist.&#39;.format(field_name))

            if many:
                for idx, item in enumerate(data):
                    try:
                        value = item[field_obj.attribute or field_name]
                    except KeyError:
                        pass
                    else:
                        validated_value = unmarshal.call_and_store(
                            getter_func=validator,
                            data=value,
                            field_name=field_obj.data_key or field_name,
                            index=(idx if self.opts.index_errors else None),
                        )
                        if validated_value is missing:
                            data[idx].pop(field_name, None)
            else:
                try:
                    value = data[field_obj.attribute or field_name]
                except KeyError:
                    pass
                else:
                    validated_value = unmarshal.call_and_store(
                        getter_func=validator,
                        data=value,
                        field_name=field_obj.data_key or field_name,
                    )
                    if validated_value is missing:
                        data.pop(field_name, None)

    def _invoke_schema_validators(
        self,
        unmarshal,
        pass_many,
        data,
        original_data,
        many,
        field_errors=False,
    ):
        for attr_name in self._hooks[(VALIDATES_SCHEMA, pass_many)]:
            validator = getattr(self, attr_name)
            validator_kwargs = validator.__marshmallow_hook__[(VALIDATES_SCHEMA, pass_many)]
            if field_errors and validator_kwargs[&#39;skip_on_field_errors&#39;]:
                continue
            pass_original = validator_kwargs.get(&#39;pass_original&#39;, False)

            if pass_many:
                validator = functools.partial(validator, many=many)
            if many and not pass_many:
                for idx, (item, orig) in enumerate(zip(data, original_data)):
                    unmarshal.run_validator(
                        validator,
                        item,
                        orig,
                        self.fields,
                        many=many,
                        index=idx,
                        pass_original=pass_original,
                    )
            else:
                unmarshal.run_validator(
                    validator,
                    data,
                    original_data,
                    self.fields,
                    many=many,
                    pass_original=pass_original,
                )

    def _invoke_processors(
        self,
        tag,
        pass_many,
        data,
        many,
        original_data=None,
    ):
        key = (tag, pass_many)
        for attr_name in self._hooks[key]:
            # This will be a bound method.
            processor = getattr(self, attr_name)

            processor_kwargs = processor.__marshmallow_hook__[key]
            pass_original = processor_kwargs.get(&#39;pass_original&#39;, False)

            if pass_many:
                if pass_original:
                    data = processor(data, many, original_data)
                else:
                    data = processor(data, many)
            elif many:
                if pass_original:
                    data = [
                        processor(item, original)
                        for item, original in zip(data, original_data)
                    ]
                else:
                    data = [processor(item) for item in data]
            else:
                if pass_original:
                    data = processor(data, original_data)
                else:
                    data = processor(data)
        return data


class Schema(with_metaclass(SchemaMeta, BaseSchema)):
    __doc__ = BaseSchema.__doc__
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2019, University of Washington.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>